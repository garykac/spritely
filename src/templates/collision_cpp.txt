// collision.cpp
// Routines to detect collisions between sprites.
// This file was automatically generated by Spritely %%_VERSION_%%

%%NDS:%%#include <nds.h>
%%GBA:%%#include <gba_video.h>

#include "collision.h"
#include "object_utils.h"
#include "sprites.h"

// Does Object1 @ (nX1,nY1) intersect with Object2 @ (nX2, nY2)
bool CollideBBox(int obj1, int obj2) {
	int x1, y1;
	int width1, height1;
	GetObjectLocation(obj1, &x1, &y1);
	GetObjectSize(obj1, &width1, &height1);
	
	int x2, y2;
	int width2, height2;
	GetObjectLocation(obj2, &x2, &y2);
	GetObjectSize(obj2, &width2, &height2);
	
	if (x1 + width1 < x2)
		return false;
	if (x2 + width2 < x1)
		return false;
	if (y1 + height1 < y2)
		return false;
	if (y2 + height2 < y1)
		return false;
		
	return true;
}

bool CollidePixel(int obj1, int obj2) {
	int s1 = GetObjectSprite(obj1);
	int s2 = GetObjectSprite(obj2);

	int x1, y1;
	GetObjectLocation(obj1, &x1, &y1);
	
	int x2, y2;
	GetObjectLocation(obj2, &x2, &y2);
	
	return CollideSprite(s1, s2, x2-x1, y2-y1);
}

inline int min(int a, int b) {
	return (a < b) ? a : b;
}

const int MaskWordWidth = 32;

bool CollideSprite(int s1, int s2, int dx, int dy) {
	// Make sure the sprite ids are valid.
	if (s1 < 0 || s1 >= kTotalSprites || s2 < 0 || s2 >= kTotalSprites )
		return false;

	// Width/height of each sprite/mask (in pixels)
	int w1 = SpriteInfo[s1].width;
	int h1 = SpriteInfo[s1].height;
	int w2 = SpriteInfo[s2].width;
	int h2 = SpriteInfo[s2].height;

	const unsigned long *mask1 = &SpriteMasks[SpriteInfo[s1].mask_index];
	const unsigned long *mask2 = &SpriteMasks[SpriteInfo[s2].mask_index];

	return CollideMask(mask1, w1, h1, mask2, w2, h2, dx, dy);
}

bool CollideMask(const unsigned long *mask1, int w1, int h1,
					const unsigned long *mask2, int w2, int h2,
					int dx, int dy) {
	// Bounding box check before going further.
	if (dx >= w1 || dy >= h1 || -dx >= w2 || -dy >= h2) {
		return false;
	}

	int mask1w = (w1 + MaskWordWidth-1) / MaskWordWidth;	
	int mask2w = (w2 + MaskWordWidth-1) / MaskWordWidth;

	// The collision masks for sprite "a" and "b". These will be set to 
	// mask1 or mask2 as appropriate.
	const unsigned long *a_mask, *b_mask;
	// Width and height of A and B masks.
	// Width is the number of maskwords; Height is number of rows
	int a_maskw, a_maskh;
	int b_maskw, b_maskh;
	// x,y offset from upper-left of A to upper-left of B
	int x_offset, y_offset;
	// Width/height of the overlap region.
	int w, h;
	
	// Select sprite A and B so that sprite B is to the right
	// of sprite A. Swap the masks and offsets if necessary.
	// After the swap, y_offset may be + or -.
	//
	//    +----------+        -
	//    |A         |        | y offset
	//    |     +---------+   -
	//    |     |B        |
	//    |     |         |
	//    +-----|         |
	//          |         |
	//          +---------+
	//
	//    |-----|
	//       x offset
	//
	if (dx >= 0) {
		a_mask = mask1;
		a_maskw = mask1w;
		a_maskh = h1;
		b_mask = mask2;
		b_maskw = mask2w;
		b_maskh = h2;
		x_offset = dx;
		y_offset = dy;
		w = min(w2, w1 - dx);
	} else {
		a_mask = mask2;
		a_maskw = mask2w;
		a_maskh = h2;
		b_mask = mask1;
		b_maskw = mask1w;
		b_maskh = h1;
		x_offset = -dx;
		y_offset = -dy;
		w = min(w1, w2 - dx);
	}
	
	// *** Don't use dx,dy or w1,h1 or w2,h2 after this point. ***
	// All references should be to A or B.
	
	// The number of bits that we need to left shift the 1st A maskword
	// to build the A mask that aligns with the B mask.
	int a_lshift = x_offset % MaskWordWidth;
	// Offset (from the beginning of the row) to the first maskword in A
	// that we need to align to B.
	int a_maskword_offset = x_offset / MaskWordWidth;
	// Number of maskwords (per row) to cover the overlap region.
	int maskword_count = (w + MaskWordWidth - 1) / MaskWordWidth;
	// Offset (from beginning of entire mask) to the first maskword that
	// we need to process for A and B.
	int a_x0, b_x0;
	// The number of maskwords left in A for this row. This is used so that
	// we don't read past the end of the current row.
	int a_x_maskwords;

	if (y_offset >= 0)
	{
		//  a---+    a---+    a---+  a---+
		//  | b-+-+  | b-+-+  |b-+|  |b-+|
		//  | | | |  | +-+-+  || ||  |+-+|
		//  +-+-+ |  +---+    ++-++  +---+
		//    +---+            +-+
		//
		a_x0 = (y_offset * a_maskw) + a_maskword_offset;
		a_x_maskwords = a_maskw - (y_offset * a_maskw);
		b_x0 = 0;
		h = min(b_maskh, a_maskh - y_offset);
	}
	else
	{
		//    b---+    b---+   b-+    b-+
		//  a-+-+ |  a-+-+ |  a+-++  a+-++
		//  | | | |  | | | |  || ||  || ||
		//  | +-+-+  | | | |  |+-+|  || ||
		//  +---+    +-+-+ |  +---+  ++-++
		//             +---+          +-+
		//
		a_x0 = a_maskword_offset;
		a_x_maskwords = a_maskw;
		b_x0 = (-y_offset * b_maskw);
		h = min(a_maskh, b_maskh + y_offset);
	}

	if (a_lshift == 0)
	{
		// The offset is aligned to maskwidth boundary - no bit shifting
		// needed.
		//
		// Example 1:
		//  a = 000000xx xxxxx000
		//  b = 00000xxx xx000000
		//  offset = 0
		//        |------||------|
		//     a  000000xxxxxxx000
		//     b  00000xxxxx000000
		//        |------||------|
		//  overlap = 16
		//  b[0] aligns with a[0]
		//  b[1] aligns with a[1]
		//
		// Example 2:
		//  a = 000000xx xxxxx000
		//  b = 00000xxx xx000000
		//  offset = 8  (this example assumes that MaskWordWidth = 8)
		//        |------||------|
		//     a  000000xxxxxxx000
		//     b          00000xxxxx000000
		//                |------||------|
		//  overlap = 8
		//  b[0] aligns with a[1]
		//
		// We loop over a column at a time since maskword_count is
		// typically 0 or 1 whereas h is between 8 and 64.
		// This reduces the times we need to calc p=&mask[x0+x].
		for (int x = 0; x < maskword_count; x++)
		{
			const unsigned long *pA = &a_mask[a_x0 + x];
			const unsigned long *pB = &b_mask[b_x0 + x];
			for (int y = 0; y < h; y++)
			{
				if ((*pA & *pB) != 0)
					return true;

				pA += a_maskw;
				pB += b_maskw;
			}
		}
	}
	else
	{
		// Each maskword in B spans 2 maskwords in A.
		// We need to shift the bits in A so that they align with B.
		//
		// Example 3:
		//  a = 000000xx xxxx0000
		//  b = 00000xxx xx000000
		//  offset = 5
		//        |------||------|
		//     a  000000xxxxxx0000
		//     b       00000xxxxx000000
		//             |------||------|
		//  overlap = 11
		//  b[0] aligns with a[0] << 5 | a[1] > 3
		//  b[1] aligns with a[1] << 5
		//
		// Example 4:
		//  a = 000000xx xxxxx000
		//  b = 00000xxx xx000000
		//  offset = 9
		//        |------||------|
		//     a  000000xxxxxxx000
		//     b           00000xxxxx000000
		//                 |------||------|
		//  overlap = 7
		//  b[0] aligns with a[1] << 1
		//
		// Example 5:
		//  a = 000000xx xxxxx000
		//  b = 00000xxx
		//  offset = 3
		//        |------||------|
		//     a  000000xxxxxxx000
		//     b     00000xxx
		//           |------|
		//  overlap = 8
		//  b[0] aligns with a[0] << 3 | a[1] >> 5
		
		// The number of bits that we need to right shift the 2nd A maskword
		// to build the A mask that aligns with the B mask.
		int a_rshift = MaskWordWidth - a_lshift;
		for (int x = 0; x < maskword_count; x++)
		{
			const unsigned long *pA = &a_mask[a_x0 + x];
			const unsigned long *pB = &b_mask[b_x0 + x];
			for (int y = 0; y < h; y++)
			{
				// Shift the A bits into the correct position.
				int a = *pA << a_lshift;
				// Merge in A bits from next word, but don't
				// read past the end of this row.
				if (x + 1 < a_x_maskwords)
					a |= *(pA+1) >> a_rshift;
					
				if ((a & *pB) != 0)
					return true;
					
				pA += a_maskw;
				pB += b_maskw;
			}
		}
	}

	return false;
}
